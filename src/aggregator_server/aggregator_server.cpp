// Copyright (c) 2015-2020 Clearmatics Technologies Ltd
//
// SPDX-License-Identifier: LGPL-3.0+

#include <boost/program_options.hpp>
#include <fstream>
#include <grpc/grpc.h>
#include <grpcpp/security/server_credentials.h>
#include <grpcpp/server.h>
#include <grpcpp/server_builder.h>
#include <grpcpp/server_context.h>
#include <iostream>
#include <memory>
#include <stdio.h>
#include <string>
#include <map>

// Necessary header to parse the data
#include <libsnark/common/data_structures/merkle_tree.hpp>

// Include the file generated by gRPC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#include "api/aggregator.grpc.pb.h"
#pragma GCC diagnostic pop

// Include the API for the given SNARK
#include "zecaleConfig.h"

#include <libzeth/circuit_types.hpp>
#include <libzeth/libsnark_helpers/libsnark_helpers.hpp>
#include <libzeth/util.hpp>
#include <libzeth/util_api.hpp>
#include <libzeth/zeth.h>

// SNARK specific imports and template instantiations
#include <libzeth/snarks_alias.hpp>
#include <libzeth/snarks_api_imports.hpp>

namespace proto = google::protobuf;
namespace po = boost::program_options;

static const size_t BatchSize = 1;

/// The aggregator_server class inherits from the Aggregator service
/// defined in the proto files, and provides an implementation
/// of the service.
class aggregator_server final : public aggregator_proto::Aggregator::Service
{
private:
    libzecale::aggregator_wrapper<CurveAggregator, CurveNestedProofs, ZETH_NUM_PROOFS> aggregator;

    // The keypair is the result of the setup for the aggregation circuit
    libzeth::keyPairT<CurveAggregator> keypair;

    // The nested verification key is the vk used to verify the nested proofs
    std::map<std::string, libzecale::application_pool<CurveNestedProofs, BatchSize>> pools_map;

public:
    explicit aggregator_server(
        libzecale::aggregate_circuit_wrapper<CurveAggregator, CurveNestedProofs, ZETH_NUM_PROOFS>
            &aggregator,
        libzeth::keyPairT<CurveAggregator> &keypair)
        : aggregator(aggregator), keypair(keypair)
    {
        // Nothing
    }

    grpc::Status GetVerificationKey(
        grpc::ServerContext *,
        const proto::Empty *,
        aggregator_proto::VerificationKey *response) override
    {
        std::cout << "[ACK] Received the request to get the verification key"
                  << std::endl;
        std::cout << "[DEBUG] Preparing verification key for response..."
                  << std::endl;
        try {
            prepare_verification_key_response<CurveAggregator>(this->keypair.vk, response);
        } catch (const std::exception &e) {
            std::cout << "[ERROR] " << e.what() << std::endl;
            return grpc::Status(
                grpc::StatusCode::INVALID_ARGUMENT, grpc::string(e.what()));
        } catch (...) {
            std::cout << "[ERROR] In catch all" << std::endl;
            return grpc::Status(grpc::StatusCode::UNKNOWN, "");
        }

        return grpc::Status::OK;
    }

    grpc::Status RegisterApplication(
        grpc::ServerContext *,
        const aggregator_proto::ApplicationRegistration *registration,
        proto::Empty *response) override
    {
        std::cout << "[ACK] Received the request to register application"
                  << std::endl;
        std::cout << "[DEBUG] Registering application..." << std::endl;
        try {
            // Add the application to the list of supported application on the
            // aggregator server.
            libzecale::application_pool app_pool(registration->name, registration->vk);
            this->pools_map[registration->name] = app_pool;
        } catch (const std::exception &e) {
            std::cout << "[ERROR] " << e.what() << std::endl;
            return grpc::Status(
                grpc::StatusCode::INVALID_ARGUMENT, grpc::string(e.what()));
        } catch (...) {
            std::cout << "[ERROR] In catch all" << std::endl;
            return grpc::Status(grpc::StatusCode::UNKNOWN, "");
        }

        return grpc::Status::OK;
    }

    grpc::Status GenerateAggregateProof(
        grpc::ServerContext *,
        const aggregator_proto::ApplicationName *app_name,
        aggregator_proto::ExtendedProof *proof) override
    {
        std::cout
            << "[ACK] Received the request to generate an aggregation proof"
            << std::endl;

        std::cout << "[DEBUG] Pop batch from the pool..." << std::endl;
        // Select the application pool corresponding to the request
        libzecale::application_pool app_pool = this->pools_map[app_name->name];
        // Retrieve batch from the pool
        std::array<libzecale::transaction_to_aggregate<CurveNestedProofs>, BatchSize> batch = app_pool.get_next_batch();

        std::cout << "[DEBUG] Parse batch and generate witness..." << std::endl;
        // Get batch of proofs to aggregate
        std::array<libzeth::extended_proof<CurveNestedProofs>, NumProofs> extended_proofs;
        for (size_t i = 0; i < batch.size(); i++){
            extended_proofs[i] = batch[i].extended_proof();
        }

        // Retrieve the application verification key for the proof aggregation
        libzeth::verificationKeyT<CurveNestedProofs> nested_vk = app_pool.verification_key();

        std::cout << "[DEBUG] Generating the proof..." << std::endl;
        libzeth::extended_proof<CurveAggregator> wrapping_proof = prove(
            nested_vk,
            extended_proofs,
            this->keypair.pk;)

        std::cout << "[DEBUG] Displaying the extended proof" << std::endl;
        wrapping_proof.dump_proof();
        wrapping_proof.dump_primary_inputs();

        std::cout << "[DEBUG] Preparing response..." << std::endl;
        libzeth::prepare_proof_response<ppT>(wrapping_proof, proof);

        catch (const std::exception &e)
        {
            std::cout << "[ERROR] " << e.what() << std::endl;
            return grpc::Status(
                grpc::StatusCode::INVALID_ARGUMENT, grpc::string(e.what()));
        }
        catch (...)
        {
            std::cout << "[ERROR] In catch all" << std::endl;
            return grpc::Status(grpc::StatusCode::UNKNOWN, "");
        }
    
        return grpc::Status::OK;
    }

    grpc::Status SubmitTransaction(
        grpc::ServerContext *,
        const aggregator_proto::TransactionToAggregate *transaction,
        proto::Empty *response) override
    {
        std::cout << "[ACK] Received the request to submit transaction"
                  << std::endl;
        std::cout << "[DEBUG] Submitting transaction..." << std::endl;
        try {
            // Add the application to the list of supported application on the
            // aggregator server.
            libzecale::transaction_to_aggregate tx = libzecale::parse_transaction_to_aggregate(*transaction);
            libzecale::application_pool app_pool = this->pools_map[registration->name];
            app_pool.add_tx(tx);
        } catch (const std::exception &e) {
            std::cout << "[ERROR] " << e.what() << std::endl;
            return grpc::Status(
                grpc::StatusCode::INVALID_ARGUMENT, grpc::string(e.what()));
        } catch (...) {
            std::cout << "[ERROR] In catch all" << std::endl;
            return grpc::Status(grpc::StatusCode::UNKNOWN, "");
        }

        return grpc::Status::OK;
    }
};

std::string get_server_version()
{
    char buffer[100];
    int n;
    // Defined in the zethConfig file
    n = snprintf(
        buffer,
        100,
        "Version %d.%d",
        ZECALE_VERSION_MAJOR,
        ZECALE_VERSION_MINOR);
    if (n < 0) {
        return "Version <Not specified>";
    }
    std::string version(buffer);
    return version;
}

void display_server_start_message()
{
    std::string copyright =
        "Copyright (c) 2015-2020 Clearmatics Technologies Ltd";
    std::string license = "SPDX-License-Identifier: LGPL-3.0+";
    std::string project = "R&D Department: PoC for a privacy preserving "
                          "scalability solution on Ethereum";
    std::string version = get_server_version();
    std::string warning = "**WARNING:** This code is a research-quality proof "
                          "of concept, DO NOT use in production!";

    std::cout << "\n=====================================================\n";
    std::cout << copyright << "\n";
    std::cout << license << "\n";
    std::cout << project << "\n";
    std::cout << version << "\n";
    std::cout << warning << "\n";
    std::cout << "=====================================================\n"
              << std::endl;
}

static void RunServer(
    libzecale::aggregator_wrapper<CurveA, CurveB, ZETH_NUM_PROOFS> &aggregator,
    libzeth::keyPairT<ppT> &keypair)
{
    // Listen for incoming connections on 0.0.0.0:50052
    // TODO: Move this in a config file
    std::string server_address("0.0.0.0:50052");

    aggregator_server service(aggregator, keypair);

    grpc::ServerBuilder builder;

    // Listen on the given address without any authentication mechanism.
    builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());

    // Register "service" as the instance through which we'll communicate with
    // clients. In this case it corresponds to an *synchronous* service.
    builder.RegisterService(&service);

    // Finally assemble the server.
    std::unique_ptr<grpc::Server> server(builder.BuildAndStart());
    std::cout << "[DEBUG] Server listening on " << server_address << std::endl;

    // Wait for the server to shutdown. Note that some other thread must be
    // responsible for shutting down the server for this call to ever return.
    display_server_start_message();
    server->Wait();
}

#ifdef ZKSNARK_GROTH16
static libzeth::keyPairT<ppT> load_keypair(const std::string &keypair_file)
{
    std::ifstream in(keypair_file, std::ios_base::in | std::ios_base::binary);
    in.exceptions(
        std::ios_base::eofbit | std::ios_base::badbit | std::ios_base::failbit);
    return libzeth::mpc_read_keypair<ppT>(in);
}
#endif

int main(int argc, char **argv)
{
    // Options
    po::options_description options("");
    options.add_options()(
        "keypair,k", po::value<std::string>(), "file to load keypair from");
#ifdef DEBUG
    options.add_options()(
        "jr1cs,j",
        po::value<boost::filesystem::path>(),
        "file in which to export the r1cs in json format");
#endif

    auto usage = [&]() {
        std::cout << "Usage:"
                  << "\n"
                  << "  " << argv[0] << " [<options>]\n"
                  << "\n";
        std::cout << options;
        std::cout << std::endl;
    };

    std::string keypair_file;
#ifdef DEBUG
    boost::filesystem::path jr1cs_file;
#endif
    try {
        po::variables_map vm;
        po::store(
            po::command_line_parser(argc, argv).options(options).run(), vm);
        if (vm.count("help")) {
            usage();
            return 0;
        }
        if (vm.count("keypair")) {
            keypair_file = vm["keypair"].as<std::string>();
        }
#ifdef DEBUG
        if (vm.count("jr1cs")) {
            jr1cs_file = vm["jr1cs"].as<boost::filesystem::path>();
        }
#endif
    } catch (po::error &error) {
        std::cerr << " ERROR: " << error.what() << std::endl;
        usage();
        return 1;
    }

    // We inititalize the curve parameters here
    std::cout << "[INFO] Init params of both curves" << std::endl;
    CurveA::init_public_params();
    CurveB::init_public_params();

    libzecale::aggregator_wrapper<CurveA, CurveB, ZETH_NUM_PROOFS> aggregator;
    libzeth::keyPairT<ppT> keypair = [&keypair_file, &aggregator]() {
        if (!keypair_file.empty()) {
#ifdef ZKSNARK_GROTH16
            std::cout << "[INFO] Loading keypair: " << keypair_file
                      << std::endl;
            return load_keypair(keypair_file);
#else
            std::cout << "Keypair loading not supported in this config"
                      << std::endl;
            exit(1);
#endif
        }

        std::cout << "[INFO] Generate new keypair" << std::endl;
        return aggregator.generate_trusted_setup();
    }();

#ifdef DEBUG
    // Run only if the flag is set
    if (jr1cs_file != "") {
        std::cout << "[DEBUG] Dump R1CS to json file" << std::endl;
        aggregator.dump_constraint_system(jr1cs_file);
    }
#endif

    std::cout << "[INFO] Setup successful, starting the server..." << std::endl;
    RunServer(aggregator, keypair);
    return 0;
}
